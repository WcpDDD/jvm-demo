@startuml
note left of ApplyCtrl
原则
1. 异步化
2. 重复io
3. 异常的调用链
4. 巨型方法
5. 重复的消耗资源的操作，比如重复值校验
6. 
end note
note left of ApplyCtrl
共性问题
1. 逻辑混乱，大量if/else的操作，尤其是表格子字段
2. 调用链混乱
3. 大量重复io
4. 该异步的不异步
end note
note over ApplyCtrl: 获取了一次form
ApplyCtrl -> PermissionChecker: 提交功能是否降级
note over ApplyCtrl: 获取了一次form_set
ApplyCtrl -> ApplyCtrl: 校验提交通道状态
ApplyCtrl -> ApplySvc: 提交校验
    group 提交校验
        note over ApplySvc: 又获取了一次form
        ApplySvc -> PermissionChecker: 校验提交权限
            group 校验申请权限
            note right
            整个方法的角色就很离谱
            大多数逻辑上都加了一个[!fromQSource]
            也就是说如果是QS则只校验表单是否关闭
            那是不是意味着表单是否关闭是个独立的行为
            end note
            note left
            调用方
            提交申请
            数据关联
            Q-Linker
            end note
            note right of PermissionChecker: 又获取了一次form_set
            note right of PermissionChecker
            这里的fromDataQueue应该指的是触发数据关联等时进行的校验
            这个时候不需要验证表单是否关闭/允许提交申请
            背景是什么？
            询问天培后表示应该是防止通过接口获取数据
            但是发起数据提交的时候有上下文不是应该更合理？
            end note
            PermissionChecker -> PermissionChecker: 如果非数据关联等则校验表单是否关闭
            PermissionChecker -> PermissionChecker: 登录可填校验
            note right of PermissionChecker: 获取一次当前的ctct_member
            PermissionChecker -> PermissionChecker: 指定用户可填校验
                group 指定用户可填
                PermissionChecker -> PermissionChecker: 用户是否存在/禁用
                PermissionChecker -> PermissionChecker: 超级管理员不进行该校验
                PermissionChecker -> PermissionChecker: 获取当前审批节点配置支持的用户
                note right of PermissionChecker
                如果这个工作区或者部门之类的用户很多可能会有点问题
                这个主要变更的时间点主要是编辑应用/通讯录变更
                属于可冗余的逻辑，但是开发成本可能会高于收益
                end note
                end
            PermissionChecker -> PermissionChecker: 工作区可填校验
            PermissionChecker -> PermissionChecker: 密码校验
            end
        ApplySvc -> QingflowLimitSvc: 商业化限制校验
        note right of QingflowLimitSvc
        主要是申请量/附件量
        这里获取的数据非常多
        几乎获取了所有的商业化限制数据
        ws_vip甚至获取了多次
        end note
            group 校验应用提交限额（正式申请）
            note right of ApplySvc: 又获取了一次form_set
            ApplySvc -> ApplySvc: 校验申请人提交限额
            note right of ApplySvc: 又一次获取了ws_vip
                note right of ApplySvc
                该方法会被QRobot/钉钉智能工作流直接调用
                原因是QRobot不需要校验申请权限
                那QS又是什么鬼？
                end note
                alt 设置了提交总量上限
                ApplySvc -> ApplySvc: 判断是否超过提交总量上限
                note right of ApplySvc: 这个应该是因为考虑到有应用被降级？
                else 如果是公有云
                ApplySvc -> ApplySvc: 免费版与付费版设置不同的提交总量上限
                end
            ApplySvc -> ApplySvc: 校验每月提交限额
            end
        ApplySvc -> AuditSvc: 校验参数合法性（正式申请）
        note right of AuditSvc: 这里再次直接进行申请人节点获取
        note right of AuditSvc: 仅正式提交申请的时候需要校验
        group 参数合法性校验
        ApplySvc -> AuditSvc: 开幕雷击，上来就先获取所有的question
            group 处理逻辑表单
            AuditSvc -> AuditSvc: 获取所有逻辑表单的queId
            AuditSvc -> AuditSvc: 遍历所有的answer，删除answer中可以关联出来的queId
            note right of AuditSvc: 如果被隐藏的是表格，则需要隐藏所有的表格子字段
            end
            AuditSvc -> AuditSvc: 将审批节点设置不可见的字段隐藏
            AuditSvc -> AuditSvc: 必填校验
            AuditSvc -> AuditSvc: 电子签章校验
            note right of AuditSvc: 此处进行了一次ws_plugin_set的io
            note right of AuditSvc
            仅在apply不为空的时候进行？
            这又是什么骚操作？
            本质上又是一个独立的行为？
            怎么再提交成功之后又开始调用这个方法了？
            end note
            AuditSvc -> AuditSvc: 验证手机号字段
            note right of AuditSvc
            看起来前端验证通过后会调接口存入一条数据
            但是这个数据不会被清空？这个本质上是不是个bug？
            现在的表现应该就是这样
            end note
            AuditSvc -> AuditSvc: 必填校验
            note right of AuditSvc: 为什么这里要重复进行必填校验？
                group 格式检查
                AuditSvc -> AuditSvc: 公有云表格行数限制
                AuditSvc -> AuditSvc: 表格行重复值校验（表格内的）
                AuditSvc -> AuditSvc: 表格子字段格式校验
                AuditSvc -> AuditSvc: 表格数据格式里面又开始娇校验不允许重复值了（应用层面的）
                note right of AuditSvc
                这是个超级狠活，每个值，每个字段，单独校验
                从单纯的编码层面的角度讲，这里可能可以走个批量
                但是从抽象的角度讲，我们是不是要针对某些字段进行“索引”操作
                比如重复值校验，比如让用户定义加速查询的字段
                这个索引的操作，该怎么做合理？
                end note
                AuditSvc -> AuditSvc: 非表格字段的数据格式检查
                AuditSvc -> AuditSvc: 附件大小检查，这个东西说实话有点自欺欺人
                AuditSvc -> AuditSvc: 电子签章是否签署校验
                note right of AuditSvc
                忽然构建个param，这是要干什么？
                而且这里应该是单纯的判断下size就行了？看起来这个遍历有点多余
                end note
                AuditSvc -> AuditSvc: 重复值校验
                note right of AuditSvc
                这整个重复值校验的代码块又完全独立于表格那里的特殊处理
                误导性非常强，看起来是表格字段不会被设置不允许重复
                end note
                end
        end

        ApplySvc -> ApplyCtrl: true
        note right of ApplySvc: 这里的return又是在干什么？
        
        ApplyCtrl -> ApplySvc: 检查应用校验条件
        note right of ApplySvc
        这里又是获取form
        然后又获取ws_vip
        end note
        note right of ApplySvc
        本质上是个应用级别的互斥锁
        但是这个form的遍历操作是不是有点离谱了
        然后这里加个锁，又是想干什么？
        这个行为的划分不对吧
        end note

        ApplyCtrl -> ApplyCtrl: 在校验失败的情况下释放校验锁
        note right of ApplyCtrl: 这个释放操作有什么价值？本身根本就没加锁

        alt 暂存
            ApplyCtrl -> ApplySvc: 开始提交数据
            note right of ApplySvc: 这个时候不会有什么提交校验相关的操作
        else 提交
            ApplyCtrl -> ApplyCtrl: 编号递增
            note right of ApplyCtrl: 又获取了一次根节点
            ApplyCtrl -> AuditValidateService: 判断是不是申请人节点
            note right of ApplyCtrl: 这东西有必要吗?
            ApplyCtrl -> AuditValidateService: 开通了手写签名的情况下，需要校验有没有签名
            ApplyCtrl -> AuditSvc: 开始进行提交重计算
            note right of AuditSvc: 先不关注这部分的逻辑
            ApplyCtrl -> AuditValidateService: 再次开始数据合法性校验了
            note right of AuditValidateService
            再次进行提交时校验了
            如果开启了提交重计算的情况下
            是不是第一次校验可以不做？
            这么做需要在重计算时兼容数据校验有问题时的逻辑？
            这个可能需要论证下
            end note
            ApplyCtrl -> ApplySvc: 正式提交数据
            note right of ApplyCtrl
            其实到这里为止提交校验应该结束了
            但是这里后续应该还有个提交时校验
            这个应该是重头戏
            这个东西后端没做？
            是出于性能的考虑？
            end note
            ApplySvc -> AuditSvc: 发起审批
            AuditSvc -> DataSvc: 更新附件/申请用量
            note right of DataSvc: 更新的时候还做了用量校验，但是有这个必要吗
            note right of DataSvc
            这里又开始获取所有的问题
            和提交校验看起来无关，但是考虑抽一个简单的上下文概念出来?
            end note
        end
    end
@enduml
